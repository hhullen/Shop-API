// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const decreaseProduct = `-- name: DecreaseProduct :one
UPDATE products
SET available_stock = available_stock - $1
WHERE uid = $2
RETURNING available_stock
`

type DecreaseProductParams struct {
	Amount int64
	Uid    uuid.UUID
}

func (q *Queries) DecreaseProduct(ctx context.Context, arg DecreaseProductParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, decreaseProduct, arg.Amount, arg.Uid)
	var available_stock int64
	err := row.Scan(&available_stock)
	return available_stock, err
}

const deleteProduct = `-- name: DeleteProduct :one
DELETE FROM products p
WHERE p.uid = $1
RETURNING p.uid
`

func (q *Queries) DeleteProduct(ctx context.Context, uid uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, deleteProduct, uid)
	err := row.Scan(&uid)
	return uid, err
}

const getAllProducts = `-- name: GetAllProducts :many
SELECT uid, name, category, price, available_stock, last_update_date, supplier_id, image_id
FROM products p
ORDER BY p.uid
`

func (q *Queries) GetAllProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.Uid,
			&i.Name,
			&i.Category,
			&i.Price,
			&i.AvailableStock,
			&i.LastUpdateDate,
			&i.SupplierID,
			&i.ImageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT uid, name, category, price, available_stock, last_update_date, supplier_id, image_id
FROM products p
WHERE p.uid = $1
`

func (q *Queries) GetProduct(ctx context.Context, uid uuid.UUID) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, uid)
	var i Product
	err := row.Scan(
		&i.Uid,
		&i.Name,
		&i.Category,
		&i.Price,
		&i.AvailableStock,
		&i.LastUpdateDate,
		&i.SupplierID,
		&i.ImageID,
	)
	return i, err
}

const getProductsPage = `-- name: GetProductsPage :many
SELECT uid, name, category, price, available_stock, last_update_date, supplier_id, image_id
FROM products p
ORDER BY p.uid
OFFSET $1
LIMIT $2
`

type GetProductsPageParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetProductsPage(ctx context.Context, arg GetProductsPageParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductsPage, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.Uid,
			&i.Name,
			&i.Category,
			&i.Price,
			&i.AvailableStock,
			&i.LastUpdateDate,
			&i.SupplierID,
			&i.ImageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertProduct = `-- name: InsertProduct :one
INSERT INTO products (uid, name, category, price,
    available_stock, last_update_date, supplier_id, image_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (uid)
DO NOTHING
RETURNING uid
`

type InsertProductParams struct {
	Uid            uuid.UUID
	Name           string
	Category       string
	Price          int64
	AvailableStock int64
	LastUpdateDate time.Time
	SupplierID     uuid.UUID
	ImageID        uuid.UUID
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertProduct,
		arg.Uid,
		arg.Name,
		arg.Category,
		arg.Price,
		arg.AvailableStock,
		arg.LastUpdateDate,
		arg.SupplierID,
		arg.ImageID,
	)
	var uid uuid.UUID
	err := row.Scan(&uid)
	return uid, err
}

const isImageAndSupplierExists = `-- name: IsImageAndSupplierExists :one
SELECT (
    EXISTS(SELECT 1 FROM images i WHERE i.uid = $1)
    AND
    EXISTS(SELECT 1 FROM suppliers s WHERE s.uid = $2)
)::bool AS is_exists
`

type IsImageAndSupplierExistsParams struct {
	ImageUid    uuid.UUID
	SupplierUid uuid.UUID
}

func (q *Queries) IsImageAndSupplierExists(ctx context.Context, arg IsImageAndSupplierExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isImageAndSupplierExists, arg.ImageUid, arg.SupplierUid)
	var is_exists bool
	err := row.Scan(&is_exists)
	return is_exists, err
}

const lockStockForUpdate = `-- name: LockStockForUpdate :one
SELECT available_stock
FROM products
WHERE uid = $1
FOR UPDATE
`

func (q *Queries) LockStockForUpdate(ctx context.Context, uid uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, lockStockForUpdate, uid)
	var available_stock int64
	err := row.Scan(&available_stock)
	return available_stock, err
}
