// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const calculateClientsWithAddress = `-- name: CalculateClientsWithAddress :one
SELECT COUNT(*) as clientsAmount 
FROM clients
WHERE address_id = $1
`

func (q *Queries) CalculateClientsWithAddress(ctx context.Context, addressID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, calculateClientsWithAddress, addressID)
	var clientsamount int64
	err := row.Scan(&clientsamount)
	return clientsamount, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteAddress, id)
	return err
}

const deleteClient = `-- name: DeleteClient :one
DELETE FROM clients WHERE uid = $1
RETURNING address_id
`

func (q *Queries) DeleteClient(ctx context.Context, uid uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteClient, uid)
	var address_id int32
	err := row.Scan(&address_id)
	return address_id, err
}

const getAllClients = `-- name: GetAllClients :many
SELECT client_name, client_surname, birthday, gender, uid, registration_date, country, city, street
FROM client_details
ORDER BY uid
`

func (q *Queries) GetAllClients(ctx context.Context) ([]ClientDetail, error) {
	rows, err := q.db.QueryContext(ctx, getAllClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientDetail
	for rows.Next() {
		var i ClientDetail
		if err := rows.Scan(
			&i.ClientName,
			&i.ClientSurname,
			&i.Birthday,
			&i.Gender,
			&i.Uid,
			&i.RegistrationDate,
			&i.Country,
			&i.City,
			&i.Street,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsPage = `-- name: GetClientsPage :many
SELECT client_name, client_surname, birthday, gender, uid, registration_date, country, city, street
FROM client_details
ORDER BY uid
OFFSET $1
LIMIT $2
`

type GetClientsPageParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetClientsPage(ctx context.Context, arg GetClientsPageParams) ([]ClientDetail, error) {
	rows, err := q.db.QueryContext(ctx, getClientsPage, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientDetail
	for rows.Next() {
		var i ClientDetail
		if err := rows.Scan(
			&i.ClientName,
			&i.ClientSurname,
			&i.Birthday,
			&i.Gender,
			&i.Uid,
			&i.RegistrationDate,
			&i.Country,
			&i.City,
			&i.Street,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsWithName = `-- name: GetClientsWithName :many
SELECT client_name, client_surname, birthday, gender, uid, registration_date, country, city, street
FROM client_details
WHERE client_name = $1 AND client_surname = $2
`

type GetClientsWithNameParams struct {
	ClientName    string
	ClientSurname string
}

func (q *Queries) GetClientsWithName(ctx context.Context, arg GetClientsWithNameParams) ([]ClientDetail, error) {
	rows, err := q.db.QueryContext(ctx, getClientsWithName, arg.ClientName, arg.ClientSurname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientDetail
	for rows.Next() {
		var i ClientDetail
		if err := rows.Scan(
			&i.ClientName,
			&i.ClientSurname,
			&i.Birthday,
			&i.Gender,
			&i.Uid,
			&i.RegistrationDate,
			&i.Country,
			&i.City,
			&i.Street,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAddress = `-- name: InsertAddress :one
INSERT INTO addresses (country, city, street)
VALUES ($1, $2, $3) ON CONFLICT (country, city, street)
DO UPDATE SET 
    country = EXCLUDED.country
RETURNING id
`

type InsertAddressParams struct {
	Country string
	City    string
	Street  string
}

func (q *Queries) InsertAddress(ctx context.Context, arg InsertAddressParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertAddress, arg.Country, arg.City, arg.Street)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertClient = `-- name: InsertClient :one
INSERT INTO clients (uid, client_name, client_surname, birthday, gender, registration_date, address_id)
VALUES ($1, $2, $3, $4, $5, $6, $7) 
ON CONFLICT (uid)
DO NOTHING
RETURNING uid
`

type InsertClientParams struct {
	Uid              uuid.UUID
	ClientName       string
	ClientSurname    string
	Birthday         time.Time
	Gender           string
	RegistrationDate time.Time
	AddressID        int32
}

func (q *Queries) InsertClient(ctx context.Context, arg InsertClientParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertClient,
		arg.Uid,
		arg.ClientName,
		arg.ClientSurname,
		arg.Birthday,
		arg.Gender,
		arg.RegistrationDate,
		arg.AddressID,
	)
	var uid uuid.UUID
	err := row.Scan(&uid)
	return uid, err
}

const updateClientAddress = `-- name: UpdateClientAddress :one
UPDATE addresses
SET country = $1, city = $2, street = $3
WHERE (SELECT address_id FROM clients WHERE uid = $4) = id
RETURNING id
`

type UpdateClientAddressParams struct {
	Country string
	City    string
	Street  string
	Uid     uuid.UUID
}

func (q *Queries) UpdateClientAddress(ctx context.Context, arg UpdateClientAddressParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, updateClientAddress,
		arg.Country,
		arg.City,
		arg.Street,
		arg.Uid,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
